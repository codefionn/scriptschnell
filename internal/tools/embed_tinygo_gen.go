//go:build ignore

package main

import (
	"flag"
	"fmt"
	"os"
	"text/template"
)

// Generate embedded TinyGo archive file based on target platform

func main() {
	// Parse flags for target platform (default to runtime values for compatibility)
	var goos, goarch string
	flag.StringVar(&goos, "goos", "", "Target GOOS (defaults to GOOS env var)")
	flag.StringVar(&goarch, "goarch", "", "Target GOARCH (defaults to GOARCH env var)")
	flag.Parse()

	// Fallback to environment variables if flags not provided
	if goos == "" {
		goos = os.Getenv("GOOS")
	}
	if goarch == "" {
		goarch = os.Getenv("GOARCH")
	}

	// Validate required parameters
	if goos == "" || goarch == "" {
		fmt.Fprintln(os.Stderr, "Error: GOOS and GOARCH must be specified via flags or environment variables")
		os.Exit(1)
	}

	args := flag.Args()
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "Usage: go run embed_tinygo_gen.go [-goos=<os>] [-goarch=<arch>] <archive_file>")
		os.Exit(1)
	}

	archivePath := args[0]

	// Read archive file (already compressed with gzip from build script)
	data, err := os.ReadFile(archivePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading archive: %v\n", err)
		os.Exit(1)
	}

	// Convert to hex format for Go embedding
	hexData := make([]string, (len(data)+15)/16)
	for i := 0; i < len(data); i += 16 {
		end := i + 16
		if end > len(data) {
			end = len(data)
		}
		var hexLine string
		for j := i; j < end; j++ {
			hexLine += fmt.Sprintf("0x%02x,", data[j])
		}
		hexData[i/16] = "\t" + hexLine
	}

	// Create output file name based on target platform
	// Use build constraints to include this file only for specific platform
	outputFile := "internal/tools/embed_tinygo_" + goos + "_" + goarch + ".go"

	// Create template with build constraints for this specific platform
	// The 'tinygo_has_embed_data' tag is used to differentiate from stub implementations
	embedTemplate := fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.
//go:build tinygo_embed && %s && %s && tinygo_has_embed_data

package tools

// Embedded TinyGo archive for %s/%s
var embeddedTinyGoArchive = []byte{
{{range .Data}}{{.}}
{{end}}}

// HasEmbeddedArchive returns true if a TinyGo archive is embedded in the binary
func HasEmbeddedArchive() bool {
	return true
}

// GetEmbeddedArchive returns the embedded TinyGo archive data
func GetEmbeddedArchive() []byte {
	return embeddedTinyGoArchive
}
`, goos, goarch, goos, goarch)

	// Execute template
	tmpl, err := template.New("embed").Parse(embedTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	outFile, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	type templateData struct {
		GOOS, GOARCH string
		Data         []string
	}

	tmplData := templateData{
		GOOS:   goos,
		GOARCH: goarch,
		Data:   hexData,
	}

	if err := tmpl.Execute(outFile, tmplData); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s (%d bytes)\n", outputFile, len(data))
}
