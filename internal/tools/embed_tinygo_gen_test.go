//go:build ignore

package main

import (
	"bytes"
	"compress/gzip"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// TestFlagParsing tests that flags are parsed correctly
func TestFlagParsing(t *testing.T) {
	tests := []struct {
		name         string
		args         []string
		envGOOS      string
		envGOARCH    string
		expectedGOOS string
		expectedArch string
		shouldError  bool
	}{
		{
			name:         "Flags provided directly",
			args:         []string{"-goos=linux", "-goarch=amd64", "test.tar.gz"},
			envGOOS:      "windows",
			envGOARCH:    "arm64",
			expectedGOOS: "linux",
			expectedArch: "amd64",
			shouldError:  false,
		},
		{
			name:         "Flags from environment variables",
			args:         []string{"test.tar.gz"},
			envGOOS:      "darwin",
			envGOARCH:    "arm64",
			expectedGOOS: "darwin",
			expectedArch: "arm64",
			shouldError:  false,
		},
		{
			name:         "No GOOS provided",
			args:         []string{"test.tar.gz"},
			envGOOS:      "",
			envGOARCH:    "amd64",
			expectedGOOS: "",
			expectedArch: "",
			shouldError:  true,
		},
		{
			name:         "No GOARCH provided",
			args:         []string{"test.tar.gz"},
			envGOOS:      "linux",
			envGOARCH:    "",
			expectedGOOS: "",
			expectedArch: "",
			shouldError:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set environment variables
			if tt.envGOOS != "" {
				os.Setenv("GOOS", tt.envGOOS)
				defer os.Unsetenv("GOOS")
			}
			if tt.envGOARCH != "" {
				os.Setenv("GOARCH", tt.envGOARCH)
				defer os.Unsetenv("GOARCH")
			}

			// Parse flags
			fs := flag.NewFlagSet("test", flag.ContinueOnError)
			var goos, goarch string
			fs.StringVar(&goos, "goos", "", "Target GOOS")
			fs.StringVar(&goarch, "goarch", "", "Target GOARCH")

			err := fs.Parse(tt.args)
			if tt.shouldError {
				if err == nil || goos == "" || goarch == "" {
					// In the actual implementation, we'd get an error or empty values
					return
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}

				// Check if values match expected
				if goos != tt.expectedGOOS {
					t.Errorf("Expected GOOS %s, got %s", tt.expectedGOOS, goos)
				}
				if goarch != tt.expectedArch {
					t.Errorf("Expected GOARCH %s, got %s", tt.expectedArch, goarch)
				}
			}
		})
	}
}

// TestHexDataGeneration tests that hex data is generated correctly
func TestHexDataGeneration(t *testing.T) {
	// Create test data
	testData := []byte{0x00, 0x01, 0x02, 0xFF, 0xAB, 0xCD}

	// Convert to hex format (as the generator does)
	hexData := make([]string, (len(testData)+15)/16)
	for i := 0; i < len(testData); i += 16 {
		end := i + 16
		if end > len(testData) {
			end = len(testData)
		}
		var hexLine string
		for j := i; j < end; j++ {
			hexLine += string([]byte{
				'0', 'x',
				"0123456789abcdef"[testData[j]>>4],
				"0123456789abcdef"[testData[j]&0xF],
				',',
			})
		}
		hexData[i/16] = "\t" + hexLine
	}

	// Verify hex data format
	expectedParts := []string{
		"0x00,", "0x01,", "0x02,", "0xff,", "0xab,", "0xcd,",
	}

	combined := strings.Join(hexData, "")
	for _, expected := range expectedParts {
		if !strings.Contains(combined, expected) {
			t.Errorf("Expected hex data to contain %s, got: %s", expected, combined)
		}
	}
}

// TestOutputFileName tests that output file names are generated correctly
func TestOutputFileName(t *testing.T) {
	tests := []struct {
		goos            string
		goarch          string
		expectedFile    string
		expectedContent string
	}{
		{
			goos:         "linux",
			goarch:       "amd64",
			expectedFile: "internal/tools/embed_tinygo_linux_amd64.go",
		},
		{
			goos:         "darwin",
			goarch:       "arm64",
			expectedFile: "internal/tools/embed_tinygo_darwin_arm64.go",
		},
		{
			goos:         "windows",
			goarch:       "amd64",
			expectedFile: "internal/tools/embed_tinygo_windows_amd64.go",
		},
	}

	for _, tt := range tests {
		t.Run(tt.goos+"_"+tt.goarch, func(t *testing.T) {
			outputFile := "internal/tools/embed_tinygo_" + tt.goos + "_" + tt.goarch + ".go"
			if outputFile != tt.expectedFile {
				t.Errorf("Expected output file %s, got %s", tt.expectedFile, outputFile)
			}
		})
	}
}

// TestTemplateContent tests that the generated template contains required elements
func TestTemplateContent(t *testing.T) {
	goos := "linux"
	goarch := "amd64"

	// Create template (simplified version of the actual generator)
	templateStr := `// Code generated by go generate; DO NOT EDIT.
//go:build tinygo_embed && %s && %s && tinygo_has_embed_data

package tools

// Embedded TinyGo archive for %s/%s
var embeddedTinyGoArchive = []byte{
{{range .Data}}{{.}}
{{end}}}

// HasEmbeddedArchive returns true if a TinyGo archive is embedded in the binary
func HasEmbeddedArchive() bool {
	return true
}

// GetEmbeddedArchive returns the embedded TinyGo archive data
func GetEmbeddedArchive() []byte {
	return embeddedTinyGoArchive
}
`

	templateStr = fmt.Sprintf(templateStr, goos, goarch, goos, goarch)

	// Verify template contains required elements
	requiredElements := []string{
		"// Code generated by go generate; DO NOT EDIT.",
		"//go:build tinygo_embed",
		goos,
		goarch,
		"tinygo_has_embed_data",
		"var embeddedTinyGoArchive = []byte{",
		"func HasEmbeddedArchive() bool {",
		"return true",
		"func GetEmbeddedArchive() []byte {",
		"return embeddedTinyGoArchive",
	}

	for _, element := range requiredElements {
		if !strings.Contains(templateStr, element) {
			t.Errorf("Expected template to contain %s", element)
		}
	}
}

// TestArchiveReading tests reading and validating archive files
func TestArchiveReading(t *testing.T) {
	// Create a temporary test archive
	tmpDir := t.TempDir()
	testArchive := filepath.Join(tmpDir, "test.tar.gz")

	// Create a simple gzipped archive
	file, err := os.Create(testArchive)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	gw := gzip.NewWriter(file)
	testData := []byte("test archive content")
	if _, err := gw.Write(testData); err != nil {
		t.Fatalf("Failed to write test data: %v", err)
	}
	if err := gw.Close(); err != nil {
		t.Fatalf("Failed to close gzip writer: %v", err)
	}
	if err := file.Close(); err != nil {
		t.Fatalf("Failed to close file: %v", err)
	}

	// Read and validate the archive
	data, err := os.ReadFile(testArchive)
	if err != nil {
		t.Fatalf("Failed to read test archive: %v", err)
	}

	// Verify it's a valid gzip file
	buf := bytes.NewReader(data)
	gzr, err := gzip.NewReader(buf)
	if err != nil {
		t.Fatalf("Failed to create gzip reader: %v", err)
	}
	defer gzr.Close()

	// Read the decompressed data
	decompressed, err := io.ReadAll(gzr)
	if err != nil {
		t.Fatalf("Failed to read decompressed data: %v", err)
	}

	if !bytes.Equal(decompressed, testData) {
		t.Errorf("Decompressed data mismatch. Expected %q, got %q", testData, decompressed)
	}
}

// TestMissingArchiveFile tests error handling when archive file doesn't exist
func TestMissingArchiveFile(t *testing.T) {
	_, err := os.ReadFile("nonexistent.tar.gz")
	if err == nil {
		t.Error("Expected error when reading nonexistent file")
	}

	// Check it's the right type of error
	if !os.IsNotExist(err) {
		t.Errorf("Expected file not found error, got %v", err)
	}
}

// TestInvalidArchivePath tests error handling for invalid archive paths
func TestInvalidArchivePath(t *testing.T) {
	// Try to read a directory instead of a file
	tmpDir := t.TempDir()

	_, err := os.ReadFile(tmpDir)
	if err == nil {
		t.Error("Expected error when reading directory as file")
	}
}

// TestEmptyArchive tests handling of empty archive files
func TestEmptyArchive(t *testing.T) {
	tmpDir := t.TempDir()
	emptyArchive := filepath.Join(tmpDir, "empty.tar.gz")

	// Create an empty file
	file, err := os.Create(emptyArchive)
	if err != nil {
		t.Fatalf("Failed to create empty file: %v", err)
	}
	file.Close()

	// Read the empty file
	data, err := os.ReadFile(emptyArchive)
	if err != nil {
		t.Fatalf("Failed to read empty file: %v", err)
	}

	if len(data) != 0 {
		t.Errorf("Expected empty file to have 0 bytes, got %d", len(data))
	}

	// Try to parse it as gzip (should fail)
	buf := bytes.NewReader(data)
	_, err = gzip.NewReader(buf)
	if err == nil {
		t.Error("Expected error when parsing empty file as gzip")
	}
}

// TestBuildConstraints tests that build constraints are correctly formatted
func TestBuildConstraints(t *testing.T) {
	tests := []struct {
		name      string
		goos      string
		goarch    string
		buildTags []string
	}{
		{
			name:      "Linux AMD64",
			goos:      "linux",
			goarch:    "amd64",
			buildTags: []string{"tinygo_embed", "linux", "amd64", "tinygo_has_embed_data"},
		},
		{
			name:      "Darwin ARM64",
			goos:      "darwin",
			goarch:    "arm64",
			buildTags: []string{"tinygo_embed", "darwin", "arm64", "tinygo_has_embed_data"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Construct build constraint string
			buildConstraint := fmt.Sprintf("//go:build %s", strings.Join(tt.buildTags, " && "))

			// Verify all tags are present
			for _, tag := range tt.buildTags {
				if !strings.Contains(buildConstraint, tag) {
					t.Errorf("Expected build constraint to contain %s", tag)
				}
			}

			// Verify format
			if !strings.HasPrefix(buildConstraint, "//go:build ") {
				t.Errorf("Build constraint should start with '//go:build'")
			}
		})
	}
}
